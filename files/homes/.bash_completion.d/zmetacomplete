# -*- Mode: shell-script -*-

# A meta-command completion function for commands like sudo(8), which need to
# first complete on a command, then complete according to that command's own
# completion definition - currently not quite foolproof (e.g. mount and umount
# don't work properly), but still quite useful
#
# _command()
# {
# 	local cur func cline cspec noglob cmd \
# 	      _COMMAND_FUNC _COMMAND_FUNC_ARGS

# 	COMPREPLY=()
# 	cur=${COMP_WORDS[COMP_CWORD]}
# #if the the first arguments following our meta-command-invoker are switches, get rid of them. Most definitely not foolproof.
#         done=
#         while [ -z $done ] ; do
#             cmd=${COMP_WORDS[1]}
#             if [[ "$cmd" == -* ]] ; then
#                 for (( i=1 ; i<=COMP_CWORD ; i++)) ; do
# #                    echo i=$i
#                     COMP_WORDS[i]=${COMP_WORDS[i+1]}
#                 done
#                 COMP_CWORD=$(($COMP_CWORD-1))
#             else
#                 done=1
#             fi
#         done

# 	if [ $COMP_CWORD -eq 1 ]; then
# 		COMPREPLY=( $( compgen -c -- $cur ) )
# 	elif complete -p $cmd &>/dev/null; then
# 		cspec=$( complete -p $cmd )
# 		if [ "${cspec#* -F }" != "$cspec" ]; then
# 			# complete -F <function>
# 			#
# 			# COMP_CWORD and COMP_WORDS() are not read-only,
# 			# so we can set them before handing off to regular
# 			# completion routine

# 			# get function name
# 			func=${cspec#*-F }
# 			func=${func%% *}
# 			# get current command line minus initial command
# 			cline="${COMP_LINE#$1 }"
# 			# save noglob state
# 		      	shopt -o noglob >/dev/null; noglob=$?
# 			# turn on noglob, as things like 'sudo ls *<Tab>'
# 			# don't work otherwise
# 		  	shopt -so noglob
# 			# split current command line tokens into array
# 			COMP_WORDS=( $cline )
# 			# reset noglob if necessary
# 			[ $noglob -eq 1 ] && shopt -uo noglob
#                         $func $cline
# 			# this is needed in case user finished entering command and pressed tab (e.g. sudo ls <Tab>)
# 			COMP_CWORD=$(( $COMP_CWORD > 0 ? $COMP_CWORD : 1 ))
# 			cur=${COMP_WORDS[COMP_CWORD]}
# 			_COMMAND_FUNC=$func
# 			_COMMAND_FUNC_ARGS=( $cmd $2 $3 )
# 			COMP_LINE=$cline
# 			COMP_POINT=$(( ${COMP_POINT} - ${#1} - 1 ))
# 			$func $cmd $2 $3
# 			# remove any \: generated by a command that doesn't
# 			# default to filenames or dirnames (e.g. sudo chown)
# 			if [ "${cspec#*-o }" != "$cspec" ]; then
# 				cspec=${cspec#*-o }
# 				cspec=${cspec%% *}
# 				if [[ "$cspec" != @(dir|file)names ]]; then
# 					COMPREPLY=("${COMPREPLY[@]//\\\\:/:}")
# 				fi
# 			fi
# 		elif [ -n "$cspec" ]; then
# 			cspec=${cspec#complete};
# 			cspec=${cspec%%$cmd};
# 			COMPREPLY=( $( eval compgen "$cspec" -- "$cur" ) );
# 		fi
# 	fi
# 	[ ${#COMPREPLY[@]} -eq 0 ] && _filedir
# }

# from /usr/share/bash-completion/bash_completion:
#complete -F _command aoss command "do" else eval exec ltrace nice nohup padsp \
#    "then" time tsocks vsound xargs

complete -F _command x xn

# _root_command()
# {
# 	PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin _command $1 $2 $3
# }
#complete -F _root_command fakeroot gksu gksudo kdesudo really
#complete -F _root_command sillysu
