#!/bin/bash

# Internal tool assumed to be called from within the xterm called by
# `x`

failure_tone() {
    beepfreq -f 500 -d 0.1 -v 0.02 > /dev/null &
}

replace_binpath() {
    sed "s!/usr/local/s?bin/!!; s!$HOME/bin/!!"
}

replace_home_tilde() {
    sed -E "s!^$HOME(/|$)!~\1!"
}

winname() {
    echo -ne '\033]2;'"$1"'\007' 1>&2
}

calculate_text_display() {
    local cmd="$1"
    shift

    # local cmd_abbr="$(                echo "$cmd" | replace_binpath | replace_home_tilde )"
    local cmd_abbr_escaped="$( printf "%q" "$cmd" | replace_binpath | replace_home_tilde )"

    printf '%s' "$cmd_abbr_escaped"

    for i in "$@" ; do
        printf ' %q' "$i"
    done
}

calculate_window_display() {
    title_columns=$(( $( tput cols )*11/10))

    (
        cmd="$1"
        shift

        cmd_abbr="$(                echo "$cmd" | replace_binpath | replace_home_tilde )"
        # cmd_abbr_escaped="$( printf "%q" "$cmd" | replace_binpath | replace_home_tilde )"

        printf '`%s' "$cmd_abbr"

        for i in "$@" ; do
            # printf ' %q' "$i"
            printf ' %s' "$i"
        done
        printf '` (%s)' "$dir_abbr"
    ) | (
        read -r title
        chomp --middle ... "$title_columns" "$title"
    )
}

usage() {
    echo "Error in internal tool called by x" 1>&2
    exit 1
}

if [ "$#" = 0 ] ; then
    usage
fi

shell=
verbose=false
clean_exit_timeout=
while [[ "$1" == -* ]] ; do
    case "$1" in
        --shell)
            shell="--shell"
            shift
            ;;
        --no-verbose|--verbose=false)
            verbose=false
            shift
            ;;
        --verbose|--verbose=true)
            verbose=true
            shift
            ;;
        -t)
            clean_exit_timeout="-t $2"
            shift ; shift
            ;;
        --*)
            usage
            ;;
    esac
done

dir="$(pwd)"
dir_abbr="$(                echo "$dir" | replace_home_tilde )"
dir_abbr_escaped="$( printf "%q" "$dir" | replace_home_tilde )"
PTS=`readlink /dev/fd/0` ; PTS="${PTS#/dev/}"

while : ; do
    window_title="$( calculate_window_display "$@" )"
    text_title="$(   calculate_text_display   "$@" )"
    winname "x ($PTS): running: $window_title"
    if $verbose ; then
        echo ">$text_title"
    fi
    echo "$( date ): running"
    colorize -n bright cyan "$text_title"
    echo -n " in "
    colorize bright magenta "$dir_abbr_escaped"
    if $verbose ; then
        verboserun $shell "$@"
    else
        if [ -n "$shell" ] ; then
            sh -c "$@"
        else
            "$@"
        fi
    fi
    exit=$?
    while read -t 0.1 purge ; do
        echo "purging STDIN: $purge"
    done
    if [ $exit = 0 ] ; then
        winname "x ($PTS): finished: $window_title"
        echo "$( date ): finished"
        colorize -n bright cyan "$text_title"
        echo -n " in "
        colorize bright magenta "$dir_abbr_escaped"
        echo "$( colorize bright green $( date ) ): $( colorize bright green Success 0 ): Press enter to exit${clean_exit_timeout:+ (Will exit in $clean_exit_timeout otherwise)}..."
        read $clean_exit_timeout
        exit
    else
        #echo "$( date ): $dir:$text_title failed..."
        failure_tone
        winname "x ($PTS): failed: $window_title"
        echo "$( colorize bright green $( date ) ): $( colorize bright red Failed $exit ): $( colorize bright magenta "$dir_abbr_escaped" )"
        echo "$( colorize bright yellow "$text_title" )"
        echo "Type 'OK' or ctrl-D to exit, or anything else to retry"
        read a || exit 1
        if [ "$a" = OK ] ; then
            exit 0
        fi
    fi
done
