#!/usr/bin/env perl
# -*- Mode: cperl; cperl-indent-level: 4; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4; c-basic-indent: 4; case-label: 4 -*-
# vi: set ai tabstop=4 expandtab softtabstop=4 shiftwidth=4:

use strict;
use warnings;
use File::Glob ':glob';
use Sys::Syslog qw(:standard);

my $scp_server   = "/usr/bin/scp";
my $rsync_server = "/usr/bin/rsync";
my $sftp_server1  = "/usr/lib64/ssh/sftp-server";
my $sftp_server2  = "/usr/libexec/openssh/sftp-server";
my %allowed_progs= ("scp" => $scp_server,
                    "rsync" => $rsync_server,
                    $sftp_server1 => $sftp_server1,
                    $sftp_server2 => $sftp_server2,
                    'internal-sftp' => $sftp_server1);

sub log;
sub include;
sub fail;

my $command;

my $ppid=getppid;
my $username=getpwuid( $< );
openlog("ssh/ssh-wrapper[$$]/[$ppid] ($username)", "", "user");

$command = $ENV{SSH_ORIGINAL_COMMAND} || "sh";   # local-wrapper will be able to override whether a login without command is allowed to succeed, but by default sh doesn't appear in %allowed_progs, so gets blocked below
$command =~ s/^\s+|\s+$//g ;  # whitespace at beginning or end is meaningless

my @SSH_CONNECTION = split(' ', $ENV{'SSH_CONNECTION'});

my $SSHClient = $SSH_CONNECTION[0];
my $SSHHost   = $SSH_CONNECTION[2];

# sanitize environment, but make sure local-wrapper can still access the original environment if required
my %env=%ENV;
%ENV = ();

my @argv = split /[ \t]+/, $command;   #will fail on filenames with spaces in them, and no way to escape them :(
my $program = shift @argv;

my $gmt = gmtime();

my @runargs=();

my $args_ok = 0;
# give local-wrapper the ability to extend %allowed_progs, do extra arg munging etc
include '/etc/ssh/wrapper/local-wrapper'
  if (-e "/etc/ssh/wrapper/local-wrapper");

fail "account restricted"
  unless defined $allowed_progs{$program};

if ($program eq "scp") {
    foreach my $arg (@argv) {
        if ($arg eq '-t' || $arg eq '-f') {
            $args_ok = 1;
            push @runargs, shift @argv;
            last;
        }
    }
} elsif ($program eq "rsync") {
    if ($#argv >= 0 && $argv[0] eq "--server") {
        $args_ok = 1;
        push @runargs, shift @argv;
    }
} elsif ($program eq $sftp_server1 or $program eq $sftp_server2 or $program eq 'internal-sftp') {
    $args_ok = 1;
}

fail "account restricted" unless $args_ok;

foreach my $a (@argv) {
    my @globs=bsd_glob($a);   # bsd_glob not susceptible to C shell injection like normal perl glob, nor splits on whitespace (man File::Glob)
#    my @globs=glob($a);
    if (!@globs) {            # we know the glob doesn't exist, but might as well give a meaningful error message back to caller
        @globs=($a);
    }
    push @runargs, @globs;
}

my $runargs = join (" ", map{"'$_'"} @runargs);
my $env_str = join (" ", map{"$_='$ENV{$_}'"} keys %ENV);
my $expanded_prog="";
if (($env_str ne "") || ($program ne $allowed_progs{$program})) {
    $env_str = "env $env_str " if $env_str ne "";
    $expanded_prog = " (=$env_str$allowed_progs{$program})";
}
writelog("success: $SSHClient->$username\@$SSHHost: $program $runargs$expanded_prog");
exec($allowed_progs{$program}, @runargs);

#subroutines with full access to lexical globals above:
sub writelog {
    my ($msg)=(@_);
    # break long lines into sets of 320 characters so syslog doesn't
    # truncate them, but long enough that context is adequate when
    # reviewing logs
    my @syslog_items=unpack('(A320)*', $msg);
    foreach my $syslog (@syslog_items) {
        syslog("notice", $syslog);
    }
}

sub fail {
    my ($msg) = @_;
    writelog("fail: $msg: $SSHClient->$username\@$SSHHost: $program @argv");
    print STDERR "$0: ", $msg, "\n";
    exit 1;
}
sub include($) {
    # http://www.perlmonks.org/?node_id=393426
    package DB;   # causes eval to evaluate the string in the caller's
    # scope.  Sometimes perl can be truly horrendous
    my ($filename) = @_;
    my $code = qq[#line 1 "$filename"\n] .
      `cat "$filename"`;
#     print STDERR "evaling code: $code\n";
    eval $code;
    if ($@) {
        die "$@";
    }
#     print STDERR "done...\n";
}

