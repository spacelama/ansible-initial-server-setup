#!/bin/bash

# x takes a shell snippet, and runs it (with shell characters allowed
# if you say --shell, however if you want to provide a file with a
# space in it, or a literal special character, you have to escape it
# (eg with printf "%q") yourself).  It can either be in a single arg
# or in a bunch of args.


# xterm might fail, due to for example running out of X11 client
# handles - keep retrying until it succeeds (this might just endlessly
# retry if you supply bogus arguments to xterm, however, in which case
# at least you get the PID printed out so you can kill it manually)
retry() {
    "$@" && return
    return_code=$?
    this_pid=$BASHPID
    while : ; do
        echo "$(colorize bright green $( date ) ): $( colorize bright red $this_pid ): $( colorize bright yellow "$( printf "%q " "$@")" ) $( colorize bright red Failed $return_code ).  Retrying in a minute (in the background)...  kill with:"
        echo "  kill $this_pid"
        sleep 60
        verboserun "$@" && return
        return_code=$?
    done
}

enforce_title_length() {
    local title="$*"

    title_limit=120 # we don't know the size the xterm will be, yet

    chomp --middle ... "$title_limit" "$title"
}

eval="verboserun"
noshell=true
verbose=false
retry=retry
wait_timeout=
while [[ "$1" == --* ]] ; do
    case "$1" in
        --help)
            cat 1>&2 <<EOF
Usage: x [--help] [--title <title>] [--no-retry] [--wait[=clean-exit-timeout]] [--no-verbose|--verbose[=<true|false>]] [--no-eval] [--shell] [--] [-other-xterm-flags...] [--] <prog> [<args>]"
Runs PROG within an xterm, setting window title and potentially retrying as necessary

  --title                 Override default calculated title (not useful with --wait)
  --wait                  Wait when a command has exited
  --wait=[0-9]*            and (exiting after a timeout if supplied, only if the command was successful)
  --no-retry              Do not attempt to retry a failed command
  --verbose               Output some extra info about command invocation and status
  --verbose=true|false
  --no-verbose            Be less verbose than default
  --no-eval               Just run the command within bash with nothing else interpreting the
                           command status, and be very quiet about invocation
  --shell                 Run the command within a shell context as well as potentially under the control
                           of our status checker
  --help                  Display this help and exit
EOF
            exit 1
            ;;
        --title)
            title="$2"
            shift 2
            ;;
        --wait*)
            if [[ "$1" == --wait=* ]] ; then
                wait_timeout="${1#--wait=}"
            fi
            shift
            eval="wait-and-query-rerun${wait_timeout:+ -t $wait_timeout}"
            ;;
        --no-retry)
            shift
            retry=
            ;;
        --no-verbose|--verbose=false)
            verbose=false
            shift
            ;;
        --verbose|--verbose=true)
            verbose=true
            shift
            ;;
        --no-eval)
            shift
            eval=
            ;;
        --shell)
            shift
            noshell=false
            ;;
        *)
            break
            ;;
    esac
done


if [ "$eval" == 'wait-and-query-rerun' ] ; then
    eval="$eval --verbose=$verbose"
    if ! $noshell ; then
        eval="$eval --shell"
    fi
elif [ "$eval" = verboserun ] ; then
    eval="$eval --verbose=$verbose"
    if ! $noshell ; then
        eval="$eval --shell"
    fi
else  # no eval, but they might still be asking for a shell (kinda the
      # same thing, eh?)
    if ! $noshell ; then
        eval='bash -c'
    fi
fi

args=()
reading_between_dashes=false
if [ "$1" = -- ] ; then
    reading_between_dashes=true
    shift
fi
while $reading_between_dashes || [[ "$1" == -* ]] ; do
    if [ "$1" == -- ] ; then
        shift
        break
    fi
    args+=("$1")
    shift
done

cmds=()
while [ $# != 0 ] ; do
    cmd="$1"
    #    if $noshell ; then
    #        cmd="$( printf "%q" "$cmd" )"
    #    fi
    cmds+=("$cmd")
    shift
done

(
    if [ "${#cmds[@]}" = 0 ] ; then
        cmds+=("bash")
    fi
    # we don't know the tty yet, nor the size of the window, so
    # there's no useful metadata to display at the front of the window
    # title to identify this window yet
    title="${title-$( enforce_title_length x: "$PWD" "${cmds[@]}" )}"
    $retry xterm "${args[@]}" -T "$title" -e $eval "${cmds[@]}" &
    sleep 0.3  # if we exit too soon, and in turn our caller (eg
               # xterm, ssh) exits, then our child might not even get
               # a chance to spawn.  This is awful, I wish there were
               # a better way to get confirmation that the xterm had
               # actually opened (plus, the retry loop could wait in
               # the foreground until the xterm succeeds in
               # opening)...
)
