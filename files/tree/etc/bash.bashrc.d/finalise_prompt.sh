# call bashrc_last as the very last thing after invoking all shell
# login bashrc etc functions, before displaying the prompt, so that we
# can set up history handling.  We ideally only want to call this the
# once, regardless of whether we're on an ansible managed system with
# everything sources out of /etc/bashrc, or whether we're just using
# our own personal config out of CVS/git
function bashrc_last() {
    #trap: need to do this before writetohistory, because it could fail
    trap 'code=$? ; exitcleanly' 0
    trap '          exitcleanly' HUP
    #    trap 'writetohistory --full' USR2

    #    if [ "$versiona" -ge 4 ] ; then  # version 4 since version 3 in rhel5 causes race condition:
    #-bash: child setpgid (20151 to 20139): Operation not permitted
    #-bash: child setpgid (20153 to 20139): Operation not permitted

    #programs that should update the title of the xterm
    #and those whose args should also be displayed
    #        trap 'generatetitle "`eval "echo "$BASH_COMMAND" | sanitise"`"' DEBUG

    setup_environment
    setup_precmd_hook
    writetohistory "@$HOSTNAME OPEN"
    finalise_login
}

# generate title before each command is executed.  Ideally, we want
# something like bash-preexec:
# https://github.com/rcaloras/bash-preexec
# https://superuser.com/questions/175799/does-bash-have-a-hook-that-is-run-before-executing-a-command
function setup_precmd_hook() {
    #        set -T  # debug trap inherited by ( subshells ) - but this means that we do a final generatetitlefromhistory just before returning to the prompt, after having already printed out the prompt title
#    trap 'generatetitlefromhistory' DEBUG     # WARNING: must be the last line before we return prompt to user for first time, because it executes for every command thereafter, interactive or not
    if [[ `uname` != *CYGWIN* ]] ; then
        # PS0 can only do at best PS0="$( do_something )", but
        # do_something will be in a subshell so won't have read-write
        # access to parent shell variables.  So instead set up a
        # signal handler in parent context, and trigger it from this
        # subshell (we were going to do something similar with SIGUSR2
        # at some point in history which we should revisit - I think
        # the problem there was that trapping it in bash meant we
        # could never reuse that signal in programs spawned by bash.
        # Choice of RTMIN sems less dangerous here)

        # https://github.com/rcaloras/bash-preexec/issues/28 ; let
        # this signal be generated by PS0 the first time it's used
        trap 'calling received signal 1>&2
              precmd_hook
              called handled signal 1>&2' SIGRTMIN
        PS0='$(
               calling sending signal 1>&2
               kill -SIGRTMIN  $$
               called back from sending signal 1>&2
            )'
    fi
}

function precmd_hook() {
    calling precmd_hook/generatetitlefromhistory
    generatetitlefromhistory
    called precmd_hook/generatetitlefromhistory
    CMD_START_SECONDS=$SECONDS
}

function finalise_login() {
    [ ! -e /sys/class/power_supply/BAT0 ] || on_ac_power 2>/dev/null || ( apm_available 2>/dev/null && ( apm ; ibam ) || ( ibam --percentbattery ) 2>/dev/null )
}
