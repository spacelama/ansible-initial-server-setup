#!/bin/ksh
# -*- Mode: shell-script -*-
#template by ~tconnors/bin/newshscript
#Thu May  1 17:20:13 EST 2008
# $Revision: 1.10 $ $Date: 2023/06/24 14:00:03 $
# $Id: colorize,v 1.10 2023/06/24 14:00:03 tconnors Exp $
# $Header: /home/tconnors/cvsroot/bin/colorize,v 1.10 2023/06/24 14:00:03 tconnors Exp $
# $RCSfile: colorize,v $

# This program colourises the text in the commandline args

#set -x

highlight() {
    if $notty ; then
        return
    fi
    bold="$2"
    bright="$3"
    background="$4"

    esc="\033["
    if $bold ; then
        fbold="1"
    else
        fbold=
    fi
    case "$1" in
        grey|black)     fore=30 ;;
        red)            fore=31 ;;
        green)          fore=32 ;;
        yellow)         fore=33 ;;
        blue)           fore=34 ;;
        magenta|purple) fore=35 ;;
        cyan)           fore=36 ;;
        white)          fore=37 ;;
        no|false|"")    fore=   ;;
        normal)         echo -ne "${open}${esc}0m${close}"
                        return
                        ;;
        *)              usageerror "supply [bold] [bright|dark] colour and text"
                        ;;
    esac

    if $bright ; then
        fore=$((fore+60))
    fi

    case "$background" in  # you'd also add 60 to get bright background
        grey|black)     back=40 ;;
        red)            back=41 ;;
        green)          back=42 ;;
        yellow)         back=43 ;;
        blue)           back=44 ;;
        magenta|purple) back=45 ;;
        cyan)           back=46 ;;
        white)          back=47 ;;
        no|false|"")    back=   ;;
        *)              usageerror "supply valid background colour"
                        ;;
    esac

    cmd="${fbold}"
    if [ -n "$fore" ] ; then
        cmd="${fbold:+${fbold};}${fore}"
    fi
    if [ -n "$back" ] ; then
        cmd="${fbold:+${fbold};}${back}"
    fi

    # good explanation for the ANSI syntax here:
    # https://www.kenmuse.com/blog/coloring-in-ansi/
    echo -ne "${open}${esc}${cmd}m${close}"
}

directoutput() {
    if $stderr ; then
        exec 1>&2
    fi
}

usage() {
    cat 1>&2 <<EOF
Usage: $0 [--stderr] [--notty] [-n|--nolf] [--PS1prompt] [--background <bgcolour>] [bold] [bright|dark] <colour> <text>
Outputs text in colour, with an option to print the output within PS1 style escapes

  --shell               Forces the command to run under a shell
  --stderr              Outputs the header information to stderr
  --notty               Doesn't output colour when piping to a command rather than tty
  -n|--nolf             Prevents output of newline at end
  --PS1prompt           Outputs the ANSI colour codes within \[...\] for incorporation within PS1 prompt
  --background          Chooses the background colour as well
  --help                Display this help and exit
  bold                  Makes the output bold
  bright                Makes the output bright
  dark                  Makes the output dark
  <colour>              Colour
  <text>                Text to output
EOF
    if [ -n "$1" ] ; then
        exit $1
    fi
    exit
}

usageerror() {
    if [ "$#" != 0 ] ; then
        echo "Usage error:" "$@" 1>&2
        echo "Usage was $ARGS" 1>&2
    fi
    usage 1
}

parseinput() {
    ARGS="$*"
    nolf=false
    open=
    close=
    bright=false
    bold=false
    colour=
    background=false
    stderr=false
    notty=false
    first=true
    while : ; do
        if ! $first ; then
            shift
        fi
        if [ "$#" -eq 0 ] ; then    #god, I wish there was an unshift in bash
            break
        fi
        first=false
        arg="$1"
        case "$arg" in
            --notty)
                if [ ! -t 1 ] ; then
                    notty=true
                fi
                ;;
            -n|--nolf)
                nolf=true
                ;;
            --PS1prompt)
                open='\['
                close='\]'
                nolf=true
                ;;
            --background)
                background="$2"
                shift
                ;;
            --stderr)
                stderr=true
                ;;
            --help)
                usage
                ;;
            --)
                shift
                break
                ;;
            -*)
                usageerror "Unknown option \"$arg\""
                ;;
            *)
                break
                ;;
        esac
    done
    if [ "$#" -lt 1 ] ; then
        usageerror "supply [bold] [bright|dark] colour and text"
    fi
    while [ "$#" -gt 2 ] ; do
        case "$1" in
            bright)
                bright=true
                shift
                ;;
            dark)
                bright=false
                shift
                ;;
            bold)
                bold=true
                shift
                ;;
            *)
                break
                ;;
        esac
    done
    colour="$1"
    shift
    if [ "$#" -lt 1 ] ; then
        usageerror "supply text"
    fi

    #assign all uneaten params to an array
    for arg in "$@" ; do
        args+=("$arg")
    done
}

args=()
parseinput "$@"

directoutput
highlight "$colour" "$bold" "$bright" $background
echo -n "${args[@]}"
highlight normal   # change the colour back before finishing the
                   # line, amongst other reasons to make sure
                   # formatting including background is back to
                   # normal before the new line is created
if ! $nolf ; then
    echo
fi
