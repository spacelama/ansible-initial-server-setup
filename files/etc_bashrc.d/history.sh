[ -z "$NONINTERACT" -a -z "$PBS_ENVIRONMENT" ] || return 0

function exitcleanly() {
    #    exiting=true
    trap - 0 HUP DEBUG
    #    cd
    #    writetohistory --full
    writetohistory "@$HOSTNAME CLOSE"
    exit $code
}

function readfromhistory() {
    history -r
}

function writetohistory() {
    #    bt
    history=$( history -a /dev/stdout ) # doesn't clear the history because in subshell
    # echo "********history=$history"
    if [ -z "$1" -a -z "$history" ] ; then
        return
    fi
    #    set -xv
    ( (
        #    echo -n "writing history..."
        mkdir -p /tmp/$USER
        lockfile -1 -r 30 -l 60 /tmp/$USER/.bash_history.lock
        PWDENC="${PWD//!/\\!}"
        history=$(
            if [ -n "$1" ] ; then
                echo "#"$(date +%s)
                echo "#######################"
            else
                echo "$history"
            fi | sed "/^#[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]$/s!\$! $PTS ${OPVIEW_VIEW:+$OPVIEW_VIEW/$OPVIEW_ITEM }$PWDENC$1!"
               )
        if [ -n "$history" ] ; then
            echo "$history" >> $HOME/.bash_fullhistory
            if [ -z "$1" ] ; then
                echo "$history" >> $HOME/.bash_history
            fi
        fi
        #    if [ "$1" == --full ] ; then
        #        command cp $HOME/.bash_fullhistory $HOME/.bash_history
        #    fi
        command rm -f /tmp/$USER/.bash_history.lock
        #    echo done
    ) & )
    #    sleep 0.3 ; echo ; echo ; echo about to clear new history, sleeping a bit to clear race possible condition, about to dedup ; echo ; sleep 0.3
    if HISTTIMEFORMAT= history 2 | sed 's/^[ 0-9]*//' | uniq -d | grep -q . ; then
        #        echo duplicated history
        lasthist=$( history 1 | awk '{print $1}' )
        hiliteStdErr echo "DEBUG: we found a duplicated history line - we will try to delete lasthist=$lasthist" 1>&2
        history 10 | hiliteStdErr cat 1>&2
        history -d $lasthist
    fi
    history -a /dev/null   # clear the history since the append is done in a subshell
    #    set +xv
    #    sleep 1 ; echo ; echo ; echo ; echo sleeping.5 ; sleep 0.5
}

# call bashrc_last as the very last thing after invoking all shell
# login bashrc etc functions, before displaying the prompt, so that we
# can set up history handling
function bashrc_last() {

    #    if [ "$TERM" = vt100 ] ; then
    #        stty erase ^h
    #    fi
    bashversion

    #cd:   so we have an stale mount point for home, lets just get a
    #      new mountpoint -- no harm done, we're exiting!
    #trap: need to do this before writetohistory, because it could fail
    trap 'code=$? ; exitcleanly' 0
    trap '          exitcleanly' HUP
    writetohistory "@$HOSTNAME OPEN"
    #    trap 'writetohistory --full' USR2

    #    if [ "$versiona" -ge 4 ] ; then  # version 4 since version 3 in rhel5 causes race condition:
    #-bash: child setpgid (20151 to 20139): Operation not permitted
    #-bash: child setpgid (20153 to 20139): Operation not permitted

    #programs that should update the title of the xterm
    #and those whose args should also be displayed
    #        trap 'generatetitle "`eval "echo "$BASH_COMMAND" | sanitise"`"' DEBUG

    # generate title before each command is executed.  Ideally, we
    # want something like bash-preexec:
    # https://github.com/rcaloras/bash-preexec
    # https://superuser.com/questions/175799/does-bash-have-a-hook-that-is-run-before-executing-a-command

    #        set -T  # debug trap inherited by ( subshells ) - but this means that we do a final generatetitlefromhistory just before returning to the prompt, after having already printed out the prompt title
#    trap 'generatetitlefromhistory' DEBUG     # WARNING: must be the last line before we return prompt to user for first time, because it executes for every command thereafter, interactive or not
    trap generatetitlefromhistory SIGRTMIN # https://github.com/rcaloras/bash-preexec/issues/28 ; let this signal be generated by PS0 the first time it's used
    PS0='$( # echo "sending signal... "
            kill -SIGRTMIN  $$; )'
    #    fi
}
