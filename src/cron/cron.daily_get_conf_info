#!/bin/bash

# for invocation from /etc/cron.daily

function backup() {
# on hosts where files are synced back to a master server and version
# controlled every half hour, we can just symlink 'rsync -L'd files
# into recovery_data, and version control them.  Otherwise we might
# have to copy the file contents into this area with cp
    err_if_not_exist=1
    if [ "$1" = --noerr ] ; then
        shift
        err_if_not_exist=
    fi
    if [ -n "$err_if_not_exist" -o -e "$1" ] ; then
#        if [[ "$1" == /sys/* ]] || [[ "$1" == /proc/* ]] ; then
            dir="$(dirname "${@: -1}")"
            mkdir -p "$dir"
            cp -aL "$@"
#        else
#            ln -s "$@"
#        fi
    fi
}

LANG=POSIX ; export LANG
PATH=/sbin:/bin:/usr/sbin:/usr/bin ; export PATH

exit=0

trap 'echo "ERROR: $hostname:$0: $LINENO: $BASH_COMMAND"; exit=1' ERR

data_dir_dest=/var/log/conf_dump
data_dir="$data_dir_dest.tmp"
rm -rf "$data_dir"   #.tmp
mkdir "$data_dir"    #.tmp
chown tconnors "$data_dir" # things like monitor_iot.worker write into it as myself

hostname=`hostname`
date=`date`
echo "Host: $hostname" > $data_dir/info
echo "Date: $date" >> $data_dir/info

# Disk info

cat /proc/partitions > $data_dir/partitions
parted -l > $data_dir/parted 2>&1 || true

[ -e /dev/disk/by-id/ ] && ls -lA /dev/disk/by-id/ > $data_dir/dev.disk.by-id
fdisk -l > $data_dir/fdisk 2>&1
cat /etc/mtab > $data_dir/mtab
df -kT > $data_dir/df 2>&1 || true
df -Ti > $data_dir/df-i 2>&1 || true
for lvm in {vg,lv,pv}{display,scan} ; do
    $lvm -v > $data_dir/$lvm 2>&1 || true
done
# but override lvdisplay above:
lvdisplay -am > $data_dir/lvdisplay 2>&1 || true
lsblk -D > $data_dir/lsblk 2>&1 || true

lvs -o+seg_all > $data_dir/lvs 2>&1 || true
pvs --segments -o+pvseg_all > $data_dir/pvs 2>&1 || true
lvs --segments -o+vg_all > $data_dir/lvs.vgall 2>&1 || true
vgs -o+vg_all > $data_dir/vgs 2>&1 || true
lvs -a -o +devices > $data_dir/lvs.devices 2>&1 || true
lvs --segments -a -o +lv_size,devices > $data_dir/lvs.sizes 2>&1 || true
pvs -o pv_name,pv_size,seg_size,vg_name,lv_name,lv_size,seg_pe_ranges > $data_dir/pvs.sizes 2>&1 || true

if [ -x /sbin/zpool ] ; then
    zpool status -v > $data_dir/zpool.status 2>&1 || true
    zfs get all > $data_dir/zfs.get.all 2>&1 || true
    zfs get -s local all > $data_dir/zfs.get.local.all 2>&1 || true
    zpool get all > $data_dir/zpool.get.all 2>&1 || true
    zpool list > $data_dir/zpool.list 2>&1 || true
    zpool list -v > $data_dir/zpool.list-v 2>&1 || true
    zfs list > $data_dir/zfs.list 2>&1 || true
fi

for i in /dev/sd? ; do
    dev="${i#/dev/}"
    smartctl -a "$i" > $data_dir/smartctl-a.$dev 2>&1 || true
done

backup /proc/mounts $data_dir/mounts
backup /proc/swaps $data_dir/swaps
if [ -e /var/lib/nfs/etab ] ; then
    cat /var/lib/nfs/etab > $data_dir/nfsd.etab
fi
if [ -e /etc/multipath/bindings -a -e /sbin/multipath ] ; then
    /sbin/multipath -ll > $data_dir/multipath_ll || true
fi

ifconfig > $data_dir/ifconfig 2>&1
ip addr show > $data_dir/ipaddr 2>&1
netstat -rn > $data_dir/netstat
(
    echo main
    ip route list table main
    echo local
    ip route list table local
) > $data_dir/route
iptables -L -n > $data_dir/iptables
iptables-save | grep -v -E '(Completed on|Generated by|ACCEPT.*\[.*:.*\])' > $data_dir/iptables-save || true

# current state of ethernet bonding:
if [ -e /sys/class/net/bonding_masters ] ; then
    for bond in `cat  /sys/class/net/bonding_masters` ; do
        ( cd /sys/class/net/$bond/bonding ; grep . * ; cd /proc/net/bonding/ ; grep . * ) > $data_dir/bond.$bond.status
    done
fi

# FIXME: raid controller status?

# dpkg packages
dpkg --get-selections | sort > $data_dir/dpkg-packages 2>&1
if [ -x /usr/bin/apt-show-versions ] ; then
    apt-show-versions > $data_dir/apt-show-versions 2>&1
fi

# Dell
if [ -e /opt/dell/srvadmin/bin/omreport ] ; then
    /opt/dell/srvadmin/bin/omreport chassis biossetup> $data_dir/dell_biossetup
fi

# Other
#backup /root/anaconda-ks.cfg $data_dir/anaconda-ks.cfg
#ls -la /usr/local > $data_dir/usr_local_list
#chkconfig --list > $data_dir/chkconfig_list 2>&1
if [ -x /bin/systemctl ] ; then
    systemctl > $data_dir/systemctl
    systemctl list-unit-files > $data_dir/chkconfig_list.systemctl
fi

/usr/bin/lsscsi > $data_dir/lsscsi 2>&1 || true

# Kernel and boot

uname -a > $data_dir/uname 2>&1
#backup /boot/config-`uname -r` $data_dir/kernel-config
backup /proc/modules $data_dir/modules
backup /proc/cpuinfo $data_dir/cpuinfo
backup /proc/meminfo $data_dir/meminfo
lscpu > $data_dir/lscpu
lspci > $data_dir/lspci 2>/dev/null || true
lspci -vvv > $data_dir/lspci-vvv 2>/dev/null || true
if [ -x /usr/sbin/dmidecode ] ; then
    dmidecode >> $data_dir/dmidecode
fi
#backup /boot/grub/menu.lst $data_dir/grub
dmesg > $data_dir/dmesg 2>&1
backup --noerr /proc/pci $data_dir/pci
sysctl -a > $data_dir/sysctl 2> $data_dir/sysctl.err
backup /proc/cmdline $data_dir/cmdline

if [ -x /usr/local/bin/get_conf_info.local ] ; then
    /usr/local/bin/get_conf_info.local $data_dir
fi

# Now, move all of the log files almost atomically to their final destination
if [ -d $data_dir_dest ] ; then
    mv $data_dir_dest $data_dir_dest.trash
fi
mv $data_dir $data_dir_dest
if [ -d $data_dir_dest.trash ] ; then
    rm -rf $data_dir_dest.trash
fi

exit $exit
